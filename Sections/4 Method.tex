\chapter{Method}
% This paper examines the structural patterns of TikTok stitch networks to quantitatively compare the topologies of different graphs and hashtag categories in TikTok StitchGraph. By analyzing whether hashtags within the same category exhibit structural similarity, the goal is to uncover patterns in how users interact and communicate on the platform. Two main approaches are employed: subgraph analysis and graph embeddings. Subgraph analysis identifies recurring subgraphs that compose the observed communication patterns within stitch networks, while graph embeddings project the networks into a lower-dimensional space to assess similarities and differences between hashtag groups. By combining subgraph analysis with graph embeddings, both micro-level patterns (e.g., motifs like star structures or chains) and macro-level patterns (e.g., clustering of hashtag categories) are detected. This dual approach facilitates a more comprehensive understanding of the communication dynamics on TikTok.

This paper examines the structural patterns of TikTok stitch networks to quantitatively compare the topologies of different graphs and hashtag categories in TikTok StitchGraph. By analyzing whether hashtags within the same category exhibit structural similarity, the goal is to uncover patterns in how users interact and communicate on the platform. Two main approaches are employed: subgraph analysis and graph representation learning. Subgraph analysis identifies recurring subgraphs that form the observed communication patterns within stitch networks, while graph representation learning focuses on deriving graph-level embeddings to represent the networks in a lower-dimensional space, enabling the evaluation of similarities and differences between hashtag groups within the learned vector representation. By combining subgraph analysis with graph embeddings, both micro-level patterns (e.g., motifs like star structures or chains) and macro-level patterns (e.g., clustering of hashtag categories) are detected. This dual approach facilitates a more comprehensive understanding of the communication dynamics on TikTok.


The presented methodology is only applied to user graphs, and not video graphs. The focus is on user graphs because they capture broader interaction patterns between users, and because of the platform-enforced constraints on video graphs. Analysis of user graphs reveals insights into user stitch behavior. Furthermore, the results of the methods are compared with Twitter reply networks to offer context and perspective from a similar well-studied social network.

% With the collected dataset, we aim to explore the structure of communication of stitches on TikTok using various network approaches. The goal is to ... We work on usergraphs... Both for standard graph and for sentiment graphs...

% Something something software used. Python 3.x, iGraph, Karate Club, networkx...


\section{Frequent Subgraph Mining}
To identify characteristic stitch patterns on TikTok, the \textit{subgraphs} that constitute the observed TikTok stitch user graphs are examined. The objective is to identify the \textit{motifs} that characterize communicative patterns on TikTok. To this end, \textit{frequent subgraph mining} is employed, a technique used to discover subgraphs that appear repeatedly within a graph \citep{coscia2021atlasaspiringnetworkscientist}. Specifically, \textit{transactional graph mining} is applied, aiming to identify subgraphs that frequently occur across a collection of graphs. In practice, this involves pruning the subgraph search space by constraining the minimum required \textit{support} of a subgraph. In a transactional setting, the support of a subgraph is the number of graphs in the graph set with which the subgraph is \textit{isomorphic}, as illustrated in Figure \ref{fig:fsm}. Note that this is fundamentally different from \textit{single graph mining}, where support is defined as the number of isomorphisms between a subgraph and a single graph. An important implication of the transactional setting is that the mined subgraphs may vary in how representative they are of specific graphs. Under the transactional support definition, a subgraph is treated as equally representative of all graphs in which it appears, even if its frequency within the graphs differs.

\begin{figure}[h]
    \centering
    \input{figures/4 method/fsm}
    \caption{The figure illustrates transactional frequent subgraph mining. Four example subgraphs are compared against the graph set to determine whether each subgraph is isomorphic to any induced subgraph from the graph set. The support of a subgraph is defined as the number of graphs in the set, where the subgraph appears. A checkmark \textcolor{ForestGreen}{\faCheck} indicates that the subgraph is found in a graph, while a cross \textcolor{red}{\faTimes} indicates it is not.}
    \label{fig:fsm}
\end{figure}

The need for isomorphism checks makes the process of frequent subgraph mining computationally intensive. Isomorphism itself is an NP-intermediate problem \citep{aaronson2016p}, and mining frequent subgraphs requires frequent isomorphism checks. This makes it difficult to implement frequent subgraph mining ourselves, and instead we opt for existing implementations, namely \textit{gSpan} \citep{yan2002gspan} and \textit{MoSS} \citep{borgelt2002moss}. We use these to mine undirected and directed structures, respectively. 

In this study, subgraphs are mined from both standard user graphs and sentiment-augmented user graphs. This approach enables us to analyze the purely topological structure of stitch communication, as well as the influence of sentiment on these topological patterns. This is done by assigning an \textit{edge color} (edge attribute) to each edge based on the sentiment of the stitch. Specifically, stitchees are assigned sentiment as an edge color since the goal is to find patterns in the reactions. We create four classes of sentiment; a positive, neutral, negative, and missing content class. 


We conduct all frequent subgraph mining on both the complete TikTok user graphs and their largest weakly connected components. All mined subgraphs are subsequently compared with Twitter graphs and relevant configuration models to compute their support for these. For this reason, we use iGraph's isomorphism function (\texttt{subisomorphic\_vf2}) for computing the support in subgraphs after they are mined\footnote{Note, in our experiments, we occasionally observed a slight difference between iGraph's computed support and the mined support from gSpan or MoSS. In this paper, we always report iGraph's computed support unless stated otherwise.} to have a comparable support between TikTok, Twitter, and configuration models. In conjunction with mining both undirected and directed graphs, we mine both purely structural patterns and sentiment patterns, resulting in eight separate frequent subgraph mining runs. 

When mining subgraphs, all self-loops are removed, but due to computational constraints, multi-edges are removed in the non-sentiment graphs. Although gSpan cannot find multigraph subgraphs, it can find simple subgraphs from a multigraph. MoSS can find multi-graph subgraphs, but it does not support self-loops. When computing the support of each mined subgraph, all self-loops and multi-edges are removed from the graph set, as their presence hinders isomorphism checks in iGraph\footnote{As of \texttt{iGraph 0.11.6}, \texttt{subisomorphic\_vf2} does not support self-loops. Furthermore, despite no documentation stating missing support for multi-edges, we empirically found that two non-isomorphic graphs can falsely return as isomorphic by iGraph if the subgraph contains a multi-edge.}. 

% Additionally, gSpan does not support multi-edges, and, based on our experience, MoSS could not complete successfully with multi-edges in the non-sentiment graphs, so these were removed. The only exception is directed sentiment graphs, with which we retain multi-edges during the mining process. 

\subsection{Undirected Subgraph Mining with gSpan}
To mine undirected subgraphs, we use gSpan \citep{yan2002gspan}. gSpan uses a minimum DFS code technique to build a lexicographic order of graphs and then subsequently uses a depth first search strategy to mine frequent connected subgraphs. For this study, we use a \texttt{C++} implementation of gSpan, provided by \cite{yan2009gspansoftware}, and ran the experiments in a \texttt{Pop!-OS} environment. To do this, all graphs are converted into a \texttt{.gspan} file format, and provided to the algorithm. gSpan supports mining from graphs with multi-edges, but does not support finding multi-edge subgraphs. We mine subgraphs down to a support threshold of $60\%$ without constraints on subgraph size. 

\subsection{Directed Subgraph Mining with MoSS}
To mine directed subgraphs, we use Molecular Substructure Miner (MoSS) \citep{borgelt2002moss}. MoSS is another frequent subgraph mining algorithm, originally developed for mining subgraphs in molecules. We use it to mine directed frequent subgraphs, as gSpan does not support edge direction. Specifically, we use a special implementation from \cite{gamer_moss}, implemented in \texttt{Java}, that supports general-purpose directed subgraph mining. MoSS employs a depth first search strategy to explore the search tree of possible subgraphs in a strategy similar to Eclat \citep{zaki1997new}, and prunes the search tree using support-based, size-based, and structural-based pruning. Pruning limits the search space based on the minimum support threshold, the maximum subgraph size limit, and ensures that each subgraph appears only in one branch of the search tree. In mining TikTok graphs, we prune the search tree by limiting the maximum substructure size to $|V|=4$ as the search tree grew too large for larger substructures and resulted in memory issues. MoSS does not support self-loops, but has no other topological restrictions. Using edge attributes in the form of sentiment classes prunes the search tree enough allowing for multi-edge mining, whereas with the unattributed version, we ran into computational constraints, leading us to mine simple no-sentiment substructures. 

\subsection{Discovering Motifs}\label{nullmodel_intro}
While the discovered subgraphs provide insight into the common patterns in the different graphs, this does not mean that these are significant. These subgraphs could appear in any graph of similar size. If a subgraph is significant, it is referred to as a motif. To discover motifs, the subgraphs should be compared to a relevant null model \citep{coscia2021atlasaspiringnetworkscientist}. A common choice for a null model is the configuration model, which preserves the degree distribution of the original graph while randomizing their connections. Comparison to this null model reveals whether the candidate motifs are significant or a product of the degree distribution. To account for randomness in the configuration models, $10$ configuration models are instantiated for each user graph. Comparisons to configuration models are only conducted for non-attributed graphs, meaning we do not do this for sentiment graphs. 

%For further comparison, we also compare this with an Erdös-Rényi random graph. 


\section{Graph Embeddings}
Graph embeddings provide a powerful framework to represent relationships and interactions in complex systems. By simplifying high-dimensional and intricate network structures, they map these systems into a lower-dimensional vector space, with the goal of capturing their structural and topological properties in numerical form.

In this study, graph embeddings are applied to analyze the structure of user graphs. Specifically, we embed and cluster $36$ distinct graphs, each representing a specific hashtag. These hashtags are divided into three predefined groups based on their themes (see Section \ref{hashtag_groups}). By studying embeddings and their clusters, we evaluate whether hashtags within a specific theme share structural properties distinct from those in other groups, offering insight into how stitch patterns vary between content topics.

\subsection{Graph Representation Learning with Graph2Vec}
To encode the graphs, we use \textit{Graph2Vec} \citep{graph2vec}, implemented by the Karate Club library \citep{karateclub}. As a method for graph representation learning, Graph2Vec encodes entire graphs into fixed-length embeddings, preserving both structural and topological characteristics. Inspired by \textit{Word2Vec} \citep{word2vec} and \textit{Doc2Vec} \citep{doc2vec}, Graph2Vec represents individual graphs as "documents" and rooted subgraphs as "words." Using the Weisfeiler-Lehman relabeling strategy \citep{shervashidze2011weisfeiler}, it captures both local and global features of the graphs. Graph2Vec adapts Doc2Vec’s skip-gram model, where the context window corresponds to the neighborhood captured by the Weisfeiler-Lehman relabeling. This skip-gram approach helps learn vector representations, which can be applied to tasks such as clustering and classification. However, like many neural representation learning methods, Graph2Vec is somewhat opaque: while we can observe the final embeddings and evaluate them in downstream tasks, it is difficult to pinpoint which specific graph structures map to particular dimensions of the resulting vectors, making it a black box algorithm. Due to the limitations of the Karate Club Library, we only apply Graph2Vec on simple graphs, i.e. we prune self-loops and multi-edges from the graphs. Lastly, Graph2Vec does not support edge-attributed graphs, and hence we refrain from embedding the sentiment graph with Graph2Vec. 

\subsection{Bag-Of-Subgraphs - A subgraph-based Graph Representation}
To represent entire graphs, a Bag-Of-Subgraphs approach is employed. The mined subgraphs from frequent subgraph mining can be used to define a subgraph-graph occurrence matrix to extract vector representations for entire graphs. This approach is analogous to the Bag-Of-Words model, but instead of using a vocabulary of words as basis vectors, it leverages subgraph isomorphisms. With this approach, each graph is represented as a collection of subgraph occurrences, ignoring their specific positions or arrangement within the graph. This yields, in contrast to Graph2Vec, an interpretable embedding space, where each dimension can be explained as the presence of a specific subgraph. This approach can be applied to all variants of graphs, since we mine undirected, directed, sentiment-undirected, and sentiment-directed subgraphs.



% \subsection{Configuration Models}
% To validate the embedding results, we generate embeddings for both real graphs and randomized baselines created using configuration models. This comparison ensures that observed patterns reflect meaningful structural properties rather than random variation. The vector representations of the graphs and null models are furthermore presented in a PCA plot to visualize the embeddings in a 2-dimensional space.

\subsection{Clustering and Group Analysis}

After embedding the graphs, we cluster them using HDBSCAN \citep{hdbscan_paper, sklearn}, a density-based algorithm that identifies clusters of varying sizes without requiring a predefined number of clusters. This approach helps group similar network structures and uncover hidden patterns within the embeddings. This is used as a means to investigate whether hashtags of the same category display similar graph properties in the embedding space and thus cluster together. For example, we can examine whether political hashtags form distinct clusters that differ significantly from entertainment- or shared-interest hashtags. If detected clusters overlap with the assigned categorization of hashtags, it points to graph topology being dependent on the nature of the hashtag. To evaluate this, Normalized Mutual Information (NMI) is applied to calculate the overlap between the two partitions. 
